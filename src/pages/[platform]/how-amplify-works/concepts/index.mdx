import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Concepts',
  description:
    'Learn about the Amplify fullstack TypeScript DX ',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

* AWS Amplify Gen 2
  * how to define backends?
    * TypeScript-based,
    * code-first developer experience (DX) /
      * unified Amplify developer experience == hosting + backend + UI-building capabilities
  * allows
    * ðŸ‘€FE developers can deploy cloud infrastructure -- via -- expressing (| TypeScript) their app's data model, business logic, authentication, authorization rulesðŸ‘€
      * Reason: ðŸ§ Amplify automatically configures the correct cloud resourcesðŸ§ 

## Capabilities

* E2E fullstack development

### Build fullstack apps with TypeScript

* authoring TypeScript -> you can provision backend infrastructure

![How Amplify capabilities can be used together or independently.](/images/gen2/how-amplify-works/amplify-flow.png)
* how to provision infrastructure Gen2 vs Gen 1
  * box at the bottom (outlined in pink)
  * | Gen 1,
    * ways
      * Studio's console, or
      * CLI
  * | Gen 2,
    * author TypeScript code / follow a file-based convention
      * allows
        * gain strict typing / prevent errors
      * file-based convention -- follows the -- "convention over configuration" paradigm
        * == if you group resource definitions by type | separate files -> know exactly where to look for
      * _Example:_ `amplify/auth/resource.ts` or `amplify/auth/data.ts`

### Faster local development

* ðŸ‘€isolated cloud sandbox development environment / EACH developer ðŸ‘€
  * allows
    * faster iterations
  * uses
    * test their changes | deploying high-fidelity AWS backends
      * Gen 2 deployments <= 8x faster Gen 1 deployments
  * isolated
    * == EACH developer work on fullstack features / WITHOUT disrupting each other's environments

![How cloud sandbox environments work.](/images/gen2/how-amplify-works/sandbox.png)

### Fullstack Git-based environments

* ALL shared environments (_Example:_ `production`, `staging`, `gamma`) -- are mapped 1:1 to -- Git branches | your repository
* NEW features can be tested | ephemeral environments
  * BEFORE merging | production
  * ways to merge to production
    * PR previews
    * feature branches
* CLI or Console, to set up a fullstack environment
  * Gen 1 requires configuration
  * Gen 2 is zero-config
* ðŸ’¡our code-first approachðŸ’¡
  * -> Git repository == source of truth for state of the fullstack app
    * == ALL backend resources -- are defined as -- code

![How fullstack deployments work.](/images/gen2/how-amplify-works/fullstack.png)

### Unified management console

* TODO:
All branches can be managed in the new Amplify console.
The Amplify Gen 2 console provides a single place for you to manage your builds, hosting settings (such as custom domains), deployed resources (such as data browser or user management), and environment variables and secrets.
Even though you can access deployed resources directly in other AWS service consoles, the Amplify console will offer a first-party experience for the categories almost every app needsâ€”data, auth, storage, and functions.
For example, with Data, Amplify offers an API playground and a data manager (coming soon) with relationship building, seed data generation, and file upload capabilities.

<Video src="/images/gen2/how-amplify-works/console.mp4" description="Video - Amplify Gen 2 Console" />

## Build an app

### Data

The `@aws-amplify/backend` library offers a TypeScript-first `Data` library for setting up fully typed real-time APIs (powered by AWS AppSync GraphQL APIs) and NoSQL databases (powered by Amazon DynamoDB tables). After you generate an Amplify backend, you will have an `amplify/data/resource.ts` file, which will contain your app's data schema. The `defineData` function turns the schema into a fully functioning data backend with all the boilerplate handled automatically.

<Callout>
  The schema-based approach is an evolution of the Amplify GraphQL API in Gen 1.
  It offers several benefits, including dot completion, IntelliSense, and type
  validation.
</Callout>

A data model for a chat app may look something like this, for example:

```ts
const schema = a.schema({
  Chat: a.model({
    name: a.string(),
    message: a.hasMany('Message', 'chatId'),
  }),
  Message: a.model({
    text: a.string(),
    chat: a.belongsTo('Chat', 'chatId'),
    chatId: a.id()
  }),
});
```

On your app's frontend, you can use the `generateClient` function, which provides a typed client instance, making it easy to integrate CRUD (create, read, update, delete) operations for your models in your application code.

<Callout>
  Gen 2 automatically generates your types without the explicit codegen step
  that was part of Gen 1.
</Callout>

```ts
// generate your data client using the Schema from your backend
const client = generateClient<Schema>();

// list all messages
const { data } = await client.models.Message.list();

// create a new message
const { errors, data: newMessage } = await client.models.Message.create({
  text: 'My message text'
});
```

### Auth

Auth works similarly to data. You can configure the authentication settings you want for your app in `amplify/auth/resource.ts`. If you want to change the verification email's subject line, you can change out the default generated code with the following:

```ts title="amplify/auth/resource.ts"
export const auth = defineAuth({
  loginWith: {
    email: {
      verificationEmailSubject: 'Welcome ðŸ‘‹ Verify your email!'
    }
  }
});
```

You can customize your authentication flow with customized sign-in and registration flows, multi-factor authentication (MFA), and third-party social providers. Amplify deploys an Amazon Cognito instance in your AWS account when you add auth to your app.

Then, you could use the Amplify `Authenticator` component or the client libraries to add user flows.

```ts
import { withAuthenticator } from '@aws-amplify/ui-react';

function App({ signOut, user }) {
  return (
    <>
      <h1>Hello {user.username}</h1>
      <button onClick={signOut}>Sign out</button>
    </>
  );
}

export default withAuthenticator(App);
```

### UI building

Amplify makes it easy to quickly build web app user interfaces using the UI component library, Figma-to-code generation, and CRUD form-generation capabilities. [Learn more.](https://ui.docs.amplify.aws/react/components)

![Screenshot showing Figma to Code](/images/gen2/how-amplify-works/ui.jpg)

## Connecting to AWS beyond Amplify

### Add any AWS resource

Gen 2 is layered on top of [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/api/v2/)â€”the Data and Auth capabilities in `@aws-amplify/backend` wrap L3 AWS CDK constructs. As a result, extending the resources generated by Amplify does not require any special configuration. The following example adds Amazon Location Services by adding a file: `amplify/custom/maps/resource.ts`.

```ts
import { CfnOutput, Stack, StackProps } from 'aws-cdk-lib';
import * as locations from 'aws-cdk-lib/aws-location';
import { Construct } from 'constructs';

export class LocationMapStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Create the map resource
    const map = new locations.CfnMap(this, 'LocationMap', {
      configuration: {
        style: 'VectorEsriStreets' // map style
      },
      description: 'My Location Map',
      mapName: 'MyMap'
    });

    new CfnOutput(this, 'mapArn', {
      value: map.attrArn,
      exportName: 'mapArn'
    });
  }
}
```

This is then included in the `amplify/backend.ts` file so it gets deployed as part of your Amplify app.

```ts
import { Backend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { LocationMapStack } from './locationMapStack/resource';

const backend = new Backend({
  auth,
  data
});

new LocationMapStack(
  backend.getStack('LocationMapStack'),
  'myLocationResource',
  {}
);
```

### Connect to existing resources

Amplify is designed to work with your existing AWS resources and configurations. For example, you can use Amplify's pre-built authentication UI components with an existing Amazon Cognito user pool you created and configured separately. Or you can display images and files from an existing Amazon S3 bucket in your app's user interface by integrating with Amplify Storage.

Amplify's libraries provide an interface to leverage your existing AWS services so that you can adopt Amplify's capabilities incrementally into your current workflows, without disrupting your existing backend infrastructure.

## Next steps

Now that you have a conceptual understanding of AWS Amplify's capabilities, complete the [quickstart tutorial](/[platform]/start/quickstart/) to put it into action in an app.
